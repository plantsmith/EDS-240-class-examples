---
title: "Lecture 2.2 TEMPLATE"
subtitle: "Visualizing distributions"
author: "Your Name"
date: 2025-01-13
toc: true
---

::: callout-note
This template follows [lecture 2.2 slides](https://eds-240-data-viz.github.io/course-materials/lecture-slides/lecture2.2-distributions-slides.html#/title-slide){target="\"_blank"}.
:::

## Setup

-   Find data & metadata on the [EDI Data Portal](https://portal.edirepository.org/nis/mapbrowse?scope=knb-lter-sbc&identifier=2007).
-   Get data download link by right-clicking on the **Download** button \> **Copy Link Address** \> then paste into `read_csv()`

```{r}
#| eval: true
#| echo: true
#| message: false
#| warning: false

##~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
##                                    setup                                 ----
##~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

#..........................load packages.........................
library(tidyverse)
library(chron)
library(naniar) #handles missing data
library(ggridges)
library(gghighlight)
library(ggbeeswarm)
library(see)
library(palmerpenguins) # for some minimal examples

#..........................import data...........................
mko <- read_csv("https://portal.edirepository.org/nis/dataviewer?packageid=knb-lter-sbc.2007.17&entityid=02629ecc08a536972dec021f662428aa")

##~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
##                                wrangle data                              ----
##~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

mko_clean <- mko |>

  # keep only necessary columns ----
  select(year, month, day, decimal_time, Temp_bot, Temp_top, Temp_mid) |>

  # create datetime column (not totally necessary for our plots, but it can be helpful to know how to do this!) ----
  unite(date, year, month, day, sep = "-", remove = FALSE) |>
  mutate(time = chron::times(decimal_time)) |>
  unite(date_time, date, time, sep = " ") |>

  # coerce data types ----
  mutate(date_time = as_datetime(date_time, "%Y-%m-%d %H:%M:%S", tz = "GMT"), 
         year = as.factor(year),
         month = as.factor(month),
         day = as.numeric(day)) |>

  # add month name by indexing the built-in `month.name` vector ----
  mutate(month_name = month.name[month]) |> 

  # replace 9999s with NAs ----
  naniar::replace_with_na(replace = list(Temp_bot = 9999, 
                                         Temp_top = 9999, 
                                         Temp_mid = 9999)) |>

  # select/reorder desired columns ----
  select(date_time, year, month, day, month_name, Temp_bot, Temp_mid, Temp_top)

##~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
##                            explore missing data                          ----
##~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

#..........counts & percentages of missing data by year..........
see_NAs <- mko_clean |> 
  group_by(year) |> 
  naniar::miss_var_summary() |>
  filter(variable == "Temp_bot")

#...................visualize missing Temp_bot...................
bottom <- mko_clean |> select(Temp_bot)
missing_temps <- naniar::vis_miss(bottom) #naniar, vis_miss is creating the visualization

# missing_temps
```

## Histograms

-   represent distribution of a numeric variable(s), which is cut into several bins -- height of bar represents \# of observations in that bin

### Too many groups

*Note the message, to remind us to consider adjusting our `binwidth`* - default is 30 bin

```{r}
#| eval: true
#| echo: true

# histogram with all 12 months ----
mko_clean |> 
  mutate(month_name = factor(month_name, levels = month.name)) |> 
# change month names from character to factor (factors have order) to put months in chronological order
  ggplot(aes(x = Temp_bot, fill = month_name)) +
  geom_histogram(position = "identity", alpha = 0.5)
```

### Alt 1: small multiples

```{r}
#| eval: true
#| echo: true
#| warning: false
#| message: false

# histogram faceted by month ----
mko_clean |> 
  mutate(month_name = factor(month_name, levels = month.name)) |> 
  ggplot(aes(x = Temp_bot, fill = month_name)) + 
  geom_histogram()+
  facet_wrap(~month_name)+
  theme_minimal()

# we dont need color in this case, as it can be distracting
mko_clean |> 
  mutate(month_name = factor(month_name, levels = month.name)) |> 
  ggplot(aes(x = Temp_bot)) + 
  geom_histogram()+
  facet_wrap(~month_name)+
  theme_minimal()
```

### Alt 2: fewer groups + update colors + modify bin widths

```{r}
#| eval: true
#| echo: true
#| warning: false

# histogram with fewer months; use these colors: c("#2C5374", "#ADD8E6", "#8B3A3A") ----
mko_clean |> 
  mutate(month_name = factor(month_name, levels = month.name)) |> 
  filter(month_name %in% c("April", "June", "October")) %>% 
  ggplot(aes(x = Temp_bot, fill = month_name)) +
  geom_histogram(position = "identity", alpha = 0.5, color = "black", binwidth = 1) +
  scale_fill_manual(values = c("#2C5374", "#ADD8E6", "#8B3A3A"))
```

## Density plots

-   "smoothed" version of a histogram

-   represent data distribution of a numeric variable(s); uses KDE to show probability density function of the variable, the y-axis represents the estimated density, i.e. the relative likelihood of a value occurring, and the area under each curve is equal to 1

### Too many groups

```{r}
#| eval: true
#| echo: true
#| warning: false

# density plot with all 12 months ----
mko_clean |> 
  mutate(month_name = factor(x = month_name, levels = month.name)) |> 
  ggplot(aes(x = Temp_bot, fill = month_name)) +
  geom_density(alpha = 0.5)
```

### Alt 1: small multiples

```{r}
#| eval: true
#| echo: true
#| warning: false

# density plot faceted by month ---- 
mko_clean %>% 
  mutate(month_name = factor(month_name, levels = month.name)) |> 
  ggplot(aes(x = Temp_bot)) +
  geom_density(fill = "gray30") +
  facet_wrap(~month_name)
```

### Alt 2: fewer groups + update colors + modify band widths

```{r}
#| eval: true
#| echo: true
#| warning: false

# density plot with fewer months; use these colors: c("#2C5374", "#ADD8E6", "#8B3A3A") ----
mko_clean |> 
  filter(month_name %in% c("April", "June", "October")) |> 
  ggplot(aes(x = Temp_bot, fill = month_name)) +
  geom_density(alpha = 0.5, adjust = 1 ) + # adjust is for 'scaling' bandwidth, 1 = default
  scale_fill_manual(values = c("#2C5374", "#ADD8E6", "#8B3A3A")) +
  theme_bw()
```

Bandwidth: smaller bandwidth = more noise, bc averaging over smaller range of values larger bandwidth = smooths out data

## A few more histograms & density plots

### Distinction: histograms vs. density plots

**Histograms** show us the counts (frequency) of values in each range (bin), represented by the height of the bars.

**Density plots** show the proportion of values in each range (area under the curve equal 1; peaks indicate where more values are concentrated, but it does *not* tell us anything about the the number of observations.

```{r}
#| eval: true
#| echo: true
#| warning: false
#| message: false
#| layout-ncol: 2

# create some dummy data ----
dummy_data <- data.frame(value = c(rnorm(n = 100, mean = 5),
                                   rnorm(n = 200, mean = 10)),
                         group = rep(c("A", "B"),
                                     times = c(100, 200)))

# Here, we have two groups (A, B) of values which are normally distributed, but with different means. Group A also has a smaller sample size (100) than group B (200).

# histogram ----
ggplot(dummy_data, aes(x = value, fill = group)) +
  geom_histogram(position = "identity", alpha = 0.7) +
  geom_rug(aes(color = group), alpha = 0.75)

# density plot ----
ggplot(dummy_data, aes(x = value, fill = group)) +
  geom_density(alpha = 0.7) +
  geom_rug(aes(color = group), alpha = 0.75)
```

### Combining geoms

```{r}
#| eval: true
#| echo: true
#| warning: false
#| message: false

# histogram + density plot ----
ggplot(mko_clean, aes(x = Temp_bot, y = after_stat(density))) + # scale down hist to match density curve
  geom_histogram(fill = "gray", color = "black", alpha = 0.75) +
  geom_density(size = 1) 
```

### Compare groups to a whole

```{r}
#| eval: true
#| echo: true
#| warning: false
# use `after_stat(count)` to plot density of observations ----
ggplot(penguins, aes(x = body_mass_g, y = after_stat(count))) +
 
  # plot full distribution curve with label "all penguins"; remove 'species' col so that this doesn't get faceted later on ----
  geom_density(data = select(penguins, -species), 
               aes(fill = "all penguins"), color = "transparent") +
  
  # plot second curve with label "species" ----
  geom_density(aes(fill = "species"), color = "transparent") +
  
  # facet wrap by species ----
  facet_wrap(~species, nrow = 1) +
  
  # update colors, x-axis label, legend position ----
  scale_fill_manual(values = c("grey","green4"), name = NULL) +
  labs(x = "Body Mass (g)") +
  theme(legend.position = "top")
```

## Ridgeline plots

-   show distribution of a numeric variable for multiple groups

```{r}
#| eval: true
#| echo: true
#| warning: false
#| message: false
#| layout-ncol: 2

# basic ridgeline plot ----

# basic ridgeline plot ----
ggplot(mko_clean, aes(x = Temp_bot, y = month_name)) +
  ggridges::geom_density_ridges()

# fill with color gradient; use these colors: c("#2C5374","#849BB4", "#D9E7EC", "#EF8080", "#8B3A3A") ----
ggplot(mko_clean, aes(x = Temp_bot, y = month_name, fill = after_stat(x))) +
# after_stat computes gradient of colors based on the x variable; tells ggplot to compute after the statistical transformation that occurs in the geom denisty later (needs info from next layer to use fill later)
  ggridges::geom_density_ridges_gradient() + 
  scale_fill_gradientn(colors = c("#2C5374","#849BB4", "#D9E7EC", "#EF8080", "#8B3A3A"))
# scale fill gradient n = n represents any number of colors 

```

### Alt 1: reorder groups + adjust overlap & tails

```{r}
#| eval: true
#| echo: true
#| warning: false
#| message: false

# ridgeline plot with reordered months ----
ggplot(mko_clean, aes(x = Temp_bot, y = month_name, fill = after_stat(x))) +
  ggridges::geom_density_ridges_gradient(rel_min_height = 0.01, scale = 3) +
# high value of scale = more overlap 
  scale_fill_gradientn(colors = c("#2C5374","#849BB4", "#D9E7EC", "#EF8080", "#8B3A3A")) + 
  scale_y_discrete(limits = rev(month.name)) #rev = reverse
```

Remember, you can also reorder factor levels during the data wrangling stage:

```{r}
#| eval: true
#| echo: true
#| warning: false
#| message: false
#| layout-ncol: 2

# e.g. by month: ----

mko_clean |> 
  mutate(month_name = factor(month_name, levels = rev(month.name))) |> 
  ggplot(aes(x = Temp_bot, y = month_name, fill = after_stat(x))) +
  ggridges::geom_density_ridges_gradient(rel_min_height = 0.01, scale = 3) +
  scale_fill_gradientn(colors = c("#2C5374","#849BB4", "#D9E7EC", "#EF8080", "#8B3A3A"))

# e.g. by median temp ---
mko_clean |> 
  mutate(month_name = fct_reorder(month_name, Temp_bot, .fun = median)) |> 
  ggplot(aes(x = Temp_bot, y = month_name, fill = after_stat(x))) +
  ggridges::geom_density_ridges_gradient(rel_min_height = 0.01, scale = 3) +
  scale_fill_gradientn(colors = c("#2C5374","#849BB4", "#D9E7EC", "#EF8080", "#8B3A3A"))
```

### Alt 2: add quantiles

```{r}
#| eval: true
#| echo: true
#| warning: false
#| message: false

# ridgeline plot with quantiles ----
# ridgeline plot with quantiles ----
ggplot(mko_clean, aes(x = Temp_bot, y = month_name)) +
  ggridges::stat_density_ridges(rel_min_height = 0.01, scale = 3,
                                quantile_lines = TRUE, quantiles = 2) +
  scale_y_discrete(limits = rev(month.name))
```

### Alt 3: jitter raw data

```{r}
#| eval: true
#| echo: true
#| layout-col: 2
#| warning: false
#| message: false

# jittered points (and raincloud option) ----
# jittered points ----
ggplot(penguins, aes(x = body_mass_g, y = species)) +
  ggridges::geom_density_ridges(jittered_points = TRUE, 
                                alpha = 0.5, point_size = 0.5)

```

```{r}
# raincloud ----
ggplot(penguins, aes(x = body_mass_g, y = species)) +
  ggridges::geom_density_ridges(jittered_points = TRUE, 
                                alpha = 0.5, point_size = 0.5, scale = 0.6,
                                position = "raincloud")
```

## Boxplots

-   ***summarize*** the distribution of a numeric variable for one or several groups
-   box plots *summarize* data, meaning we canâ€™t see the underlying shape of the distribution or sample size

<!-- -->

-   add jittered points on top, or if large sample size, consider a violin plot

```{r}
#| eval: true
#| echo: true
#| warning: false

# boxplot with all 12 months ----
ggplot(mko_clean, aes(x = month_name, y = Temp_bot)) +
  geom_boxplot() +
  scale_x_discrete(limits = rev(month.name)) + # put the months in cronological order
  coord_flip()
```

### Alt 1: modify outliers

```{r}
#| eval: true
#| echo: true
#| warning: false

# boxplot with modified outliers ----
ggplot(mko_clean, aes(x = month_name, y = Temp_bot)) +
  geom_boxplot(outlier.color = "purple", outlier.shape = 1, outlier.size = 5) +
  scale_x_discrete(limits = rev(month.name)) +
  coord_flip()
```

### Alt 2: hightlight a group

```{r}
#| eval: true
#| echo: true
#| warning: false

# highlight a particular group ----
ggplot(mko_clean, aes(x = month_name, y = Temp_bot, fill = month_name)) +
  geom_boxplot() +
  scale_x_discrete(limits = rev(month.name)) +
  gghighlight::gghighlight(month_name == "October") + #highlight October
  coord_flip() +
  theme(legend.position = "none")
```

### Alt 3: jitter raw data (using `{palmerpenguins}` data)

```{r}
#| eval: true
#| echo: true
#| warning: false

# add jittered data points ----
ggplot(penguins, aes(x = species, y = body_mass_g)) +
  geom_boxplot(outlier.shape = NA) + #outlier shape = NA removes redundant outlier info
  geom_jitter(alpha = 0.5, width = 0.2) 
# scatter plot but add a bit of noise so you can see points
```

### Alt 4: dodged groups

```{r}
#| eval: true
#| echo: true
#| warning: false

# dodge groups by year ----
ggplot(penguins, aes(x = species, y = body_mass_g, color = as.factor(year))) +
  geom_boxplot(outlier.shape = NA) +
  geom_point(alpha = 0.5, 
             position = position_jitterdodge(jitter.width = 0.2))
```

### Alt 5: overlay beeswarm

```{r}
#| eval: true
#| echo: true
#| warning: false

# boxplot + beeswarm ----
ggplot(penguins, aes(x = species, y = body_mass_g)) +
  geom_boxplot(outlier.shape = NA) +
  ggbeeswarm::geom_beeswarm(size = 1) 
```

## Violin plots

-   visualize distribution of a numeric variable for one or several groups; great for multiple groups with lots of data

```{r}
#| eval: true
#| echo: true
#| warning: false

# violin plot ----
ggplot(mko_clean, aes(x = month_name, y = Temp_bot)) +
  geom_violin() +
  scale_x_discrete(limits = rev(month.name)) +
  coord_flip()
```

### Alt 1: overlay boxplot

```{r}
#| eval: true
#| echo: true
#| warning: false

# violin + boxplot ----
ggplot(mko_clean, aes(x = month_name, y = Temp_bot)) +
  geom_violin() +
  geom_boxplot(width = 0.1, color = "gray", alpha = 0.5, 
               outlier.color = "red") +
# play around with size until it looks good
  scale_x_discrete(limits = rev(month.name)) +
  coord_flip()
```

### Alt 2: half-violin half-dot plot

```{r}
#| eval: true
#| echo: true
#| warning: false

# half violin + half dot plot ----
ggplot(penguins, aes(x = species, y = bill_length_mm, fill = species)) +
  see::geom_violindot(size_dots = 5, alpha = 0.5) +
  theme(legend.position = "none")
```
